// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;




/*1. string을 input으로 받는 함수를 구현하세요. "Alice"나 "Bob"일 때에만 true를 반환하세요.*/
contract Q31{
    function convert(string memory _name) public pure returns(bool){
     if(keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked("Alice")) || keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked("Bob"))){
        return true;
     }else{
        return false;
     }
    }
}
   
/*3의 배수만 들어갈 수 있는 array를 구현하되, 3의 배수이자 동시에 10의 배수이면 들어갈 수 없는 추가 조건도 구현하세요.
예) 3 → o , 9 → o , 15 → o , 30 → x */
contract Q32{
    uint[] A;
    function convert(uint _n) public returns(uint[] memory){
    
    if(_n % 3 == 0){
       A.push(_n);
    } else{
        require (_n % 3 == 0 && _n % 5 == 0, "unvaild number");
    }
    return A;
}
    function getA() public view  returns(uint[] memory){
        return A;
    }

}
/*상태변수를 선언하지 않고, 1,2,3말고 딱 3만 넣게 어떻게 하지? 다시 해보자
function convert(uint _n) public pure returns(uint[] memory){
    uint[] memory A = new uint[](_n);
    if(_n % 3 == 0){
       for(uint i =0; i < _n; i++){
        A[i] = i + 1;
       }
    } else{
        require (_n % 3 == 0 && _n % 5 == 0, "unvaild number");
    }
    return A;
}*/ 

    

/*이름, 번호, 지갑주소 그리고 생일을 담은 고객 구조체를 구현하세요. 고객의 정보를 넣는 함수와 고객의 이름으로 검색하면 해당 고객의 전체 정보를 반환하는 함수를 구현하세요.*/
contract Q33{
    struct customer{
        uint _number;
        string _name;
        address _wallet;

    }

    customer[] customers;
    
    function addCustomer(uint _number, string memory _name, address _wallet) public {
        customers.push(customer(_number, _name, _wallet));
         //구조체에 여러개 집어 넣을 때 묶어서 넣는 거 까먹지 말기
    }

    function getCustomer(string memory) public view returns(customer[] memory){
        return customers;

    } 
}


    
/*이름, 번호, 점수가 들어간 학생 구조체를 선언하세요. 학생들을 관리하는 자료구조도 따로 선언하고 학생들의 전체 평균을 계산하는 함수도 구현하세요.*/
/*contract Q34{
    struct student{
        uint _number;
        string _name;
        uint _score;
    }
    
    student[] students;

    function average(uint) public view returns(uint) {
     
    }
 
    
}*/




/*숫자만 들어갈 수 있는 array를 선언하고 해당 array의 짝수번째 요소만 모아서 반환하는 함수를 구현하세요.
    예) [1,2,3,4,5,6] -> [2,4,6] // [3,5,7,9,11,13] -> [5,9,13]*/

/*contract Q35{
    uint[] numbers;
    
    function add(uint _n) public {
        numbers.push(_n);
    }

    function even() public view returns(uint[] memory){
       uint[] memory numbers = new uint[](numbers.length /2)
       uint
    }
   
}*/

    
 
/*high, neutral, low 상태를 구현하세요. a라는 변수의 값이 7이상이면 high, 4이상이면 neutral 그 이후면 low로 상태를 변경시켜주는 함수를 구현하세요.*/
contract Q36{
    string status;
    function Change(uint _n)public{
        if(_n >= 7){
            status = "high";
        }else if(_n >= 4){
            status = "neutral";
        }else{
            status = "low";
        }
            
    }
}

/*1 wei를 기부하는 기능, 1finney를 기부하는 기능 그리고 1 ether를 기부하는 기능을 구현하세요. 최초의 배포자만이 해당 smart contract에서 자금을 회수할 수 있고 다른 이들은 못하게 막는 함수도 구현하세요.
    (힌트 : 기부는 EOA가 해당 Smart Contract에게 돈을 보내는 행위, contract가 돈을 받는 상황)*/
contract Q37{
    address payable owner;

    constructor() {
        owner = payable(msg.sender);
    }

    function donation1Wei() public payable {
        require(msg.value == 1 wei, "NO");
    }

    function donation1Finney() public payable{
        require(msg.value == 1 ether / 1000, "NO");
    }

    function donation1ETH() public payable{
        require(msg.value == 1 ether, "No");
    }

     function withdraw() public {
        require(msg.sender == owner, "NO");
        owner.transfer(address(this).balance);
    }
    
    
}
    
  
/*상태변수 a를 "A"로 설정하여 선언하세요. 이 함수를 "B" 그리고 "C"로 변경시킬 수 있는 함수를 각각 구현하세요. 단 해당 함수들은 오직 owner만이 실행할 수 있습니다. owner는 해당 컨트랙트의 최초 배포자입니다.
    (힌트 : 동일한 조건이 서로 다른 두 함수에 적용되니 더욱 효율성 있게 적용시킬 수 있는 방법을 생각해볼 수 있음)*/
contract Q38{

    address payable owner;

    enum status{
        a,
        B,
        C
    }

    constructor() {
        owner = payable(msg.sender);
    }
    
    status public A = status.a;

    function changeB() public {
        require(msg.sender == owner, "no");
        A = status.B;
    }
    function changeC() public{
        require(msg.sender == owner, "no");
        A = status.C;
    }


}

    
/*특정 숫자의 자릿수까지의 2의 배수, 3의 배수, 5의 배수 7의 배수의 개수를 반환해주는 함수를 구현하세요.   
 예) 15 : 7,5,3,2  (2의 배수 7개, 3의 배수 5개, 5의 배수 3개, 7의 배수 2개) // 100 : 50,33,20,14  (2의 배수 50개, 3의 배수 33개, 5의 배수 20개, 7의 배수 14개)*/
 contract Q39{
    function div(uint _n) public pure returns(uint, uint, uint, uint){
        return (_n / 2, _n / 3, _n / 5, _n / 7);
    }
    
 }
    
/* 숫자를 임의로 넣었을 때 내림차순으로 정렬하고 가장 가운데 있는 숫자를 반환하는 함수를 구현하세요. 가장 가운데가 없다면 가운데 2개 숫자를 반환하세요.
     예) [5,2,4,7,1] -> [1,2,4,5,7], 4 // [1,5,4,9,6,3,2,11] -> [1,2,3,4,5,6,9,11], 4,5 // [6,3,1,4,9,7,8] -> [1,3,4,6,7,8,9], 6 */

contract Q40{
    function sorting(uint[]memory) public pure returns(uint[] memory, uint[]memory){
        
    }
}

   
